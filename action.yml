name: Update Gruntwork Pipelines PR Status
description: "Update Gruntwork Pipelines PR Status"
inputs:
  step_name:
    description: "The name of the step to update.  Combined with step_working_directory to form a unique key for this update"
  step_working_directory:
    description: "The working directory where the update is happening.  Combiend with step_name to form a unique key for this update"
  step_status:
    description: "The status of the step to update"
    default: "not_started"
  step_details_preview:
    description: "Preview Text for details"
    default: "Output"
  step_details:
    description: "Details or output from the step"
    default: ""
  first_update:
    description: "Set this to 'true' on the very first update in a pipeline run to avoid spurious artifact action errors"
    default: "false"
  pull_request_number:
    description: "The Pull request to update"
    required: false
  summary_status:
    description: "A summary of the overall status of the pipeline"
    required: false
  orchestrate_jobs:
    description: "The output of pipelines orchestrate, used to scaffold the status update"
    required: false
    default: ''
  step_details_extended:
    description: ""
    required: false
    default: ""

runs:
  using: composite
  steps:
    - name: Set up mutex
      id: mutex
      uses: gruntwork-io/gh-action-mutex@main

    - name: Download artifact
      uses: actions/download-artifact@v4
      if: inputs.first_update != 'true'
      continue-on-error: true
      with:
        name: state

    - name: Sanitize the name
      id: step_name
      shell: bash
      run: |
        name=$(echo ${{ inputs.step_name }} | sed -E 's/([a-z])([A-Z])/\1 \2/g' | xargs)
        echo "formatted_name=$name" >> "$GITHUB_OUTPUT"

    - name: Calculate Initial State from Jobs
      if: inputs.orchestrate_jobs != ''
      shell: bash
      run: |
        echo '{}' > state.json
        if [[ ! -z '${{ inputs.orchestrate_jobs }}' ]]; then
          echo '${{ inputs.orchestrate_jobs }}' > jobs.json
          NUM_JOBS=$(cat jobs.json | jq -c '. | length')
          if [[ $NUM_JOBS -gt 0 ]]; then
            echo "jobs.json is not empty..."
            for i in $(seq 0 $(($NUM_JOBS - 1))); do
              job=$(cat jobs.json | jq -c ".[$i]")
              echo $job
              change_type=$(echo "$job" | jq -r '.ChangeType')
              echo "change_type=$change_type"
              working_directory=$(echo "$job" | jq -r '.WorkingDirectory')
              echo "working_directory=$working_directory"
              name=$(echo $change_type | sed 's/[A-Z]/ \U&/g' | xargs)
              echo "name=$name"
              key="$name|$working_directory"
              echo "building new json object.."
              NEWJSON='{ "'$key'": { "name": "'$name'", "status": "in_progress", "status_icon": "🔄", "details_preview": "Output", "details": "🔄 Running Terragrunt...", "working_directory": "'$working_directory'"}}'
              echo $NEWJSON
              echo "building new state..."
              jq ". + $NEWJSON" state.json > updated_state.json
              mv updated_state.json state.json
            done
          fi
        fi
    - name: Calculate Table
      id: calculate
      shell: bash
      env:
        IS_PLAN: ${{ github.event_name == 'pull_request' }}
        STEP_DETAILS_EXTENDED: ${{ inputs.step_details_extended }}
      run: |
        function statusToIcon() {
          status=$1
          if [[ "$status" = "not_started" ]]; then
            echo "⚪"
            return
          fi
          if [[ "$status" = "in_progress" ]]; then
            echo "🔄"
            return
          fi
          if [[ "$status" = "success" ]]; then
            echo "✅"
            return
          fi
          if [[ "$status" = "failed" ]]; then
            echo "❌"
            return
          fi
          echo $status
        }

        # Ensure we have a statefile
        if [[ ! -f "state.json" ]]; then
          echo '{}' > state.json
        fi

        icon=$(statusToIcon ${{ inputs.step_status }})
        TMPFILE=${{ runner.temp }}/message.txt

        # Convert the incoming step details to JSON to make sure it fits inside the state file
        echo '${{ toJson(inputs.step_details) }}' > details.json
        if [[ -z '${{ inputs.step_details }}' ]]; then
          echo "setting details to empty json..."
          echo '""' > details.json
        fi

        echo "New Details as JSON:"
        cat details.json

        # If a step name is passed, then update the state file with new step details
        # If no step name is passed, we'll just create a comment with the existing state
        if [[ ! -z '${{ steps.step_name.outputs.formatted_name }}' ]]; then
          echo "building new json object.."
          key="${{ steps.step_name.outputs.formatted_name }}|${{ inputs.step_working_directory }}"
          JQSTR='{ "'$key'": { "name": "${{ steps.step_name.outputs.formatted_name }}", "status": "${{ inputs.step_status }}", "status_icon": "'$icon'", "working_directory": "'${{ inputs.step_working_directory }}'", "details_preview": "${{ inputs.step_details_preview }}", "details": . }}'
          echo $JQSTR
          NEWJSON=$(jq "$JQSTR" details.json)
          echo $NEWJSON
          echo "building new state..."
          jq ". + $NEWJSON" state.json > updated_state.json
          cat state.json
          cat updated_state.json
          mv updated_state.json state.json
        fi

        echo "<details open><summary>" > $TMPFILE
        logs_link="<a href=\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\">logs</a>"
        if [[ $IS_PLAN == 'true' ]]; then
          echo "<h2>Gruntwork Pipelines Plan ${{ github.event.pull_request.head.sha  }} ($logs_link)</h2>" >> $TMPFILE
        else
          echo "<h2>Gruntwork Pipelines Apply ${{ github.event.pull_request.head.sha  }} ($logs_link)</h2>" >> $TMPFILE
        fi
        echo "</summary>" >> $TMPFILE

        if [[ ! -z '${{ inputs.summary_status }}' ]]; then
          echo "${{ inputs.summary_status }}<br />" >> $TMPFILE
        fi

        NUM_STEPS=$(cat state.json | jq -c '. | values[]' | wc -l)

        if [[ $NUM_STEPS -gt 0 ]]; then
          IFS=$'\n'
          for item in $(cat state.json | jq -c '. | values[]'); do
              echo "single item..."
              echo $item
              name=$(echo "$item" | jq -r '.name')
              status_icon=$(echo "$item" | jq -r '.status_icon')
              details=$(echo "$item" | jq -r '.details')
              working_directory=$(echo "$item" | jq -r '.working_directory')
              details_preview=$(echo "$item" | jq -r '.details_preview')
              if [[ ! -z "$working_directory" ]]; then
                module=$(basename $working_directory)
                echo "<table><tr><td align='left' width='800px'>$status_icon <b>$name:</b> <code>$module</code> (<a href=\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\">logs</a>)</td></tr>" >> $TMPFILE
              else
                echo "<table><tr><td align='left' width='800px'>$status_icon <b>$name</b> (<a href=\"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\">logs</a>)</td></tr>" >> $TMPFILE
              fi

              echo "<tr><td>" >> $TMPFILE
              if [[ ! -z "$working_directory" ]]; then
                echo "<code>$working_directory</code><br /><br />" >> $TMPFILE
              fi
              if [[ ! -z "$details" ]]; then
                echo "$details" >> $TMPFILE
              fi
              extended=$(
              cat <<- EOF
              <details><summary>Plan Output</summary>

              ```
              $STEP_DETAILS_EXTENDED
              ```

              </details>
        EOF

              )
              echo "$extended" >> $TMPFILE

              echo "</td></tr>" >> $TMPFILE

            echo "</table>" >> $TMPFILE
          done
        fi

        echo "</details>" >> $TMPFILE
        cat $TMPFILE
        echo "tmpfile=$TMPFILE" >> "$GITHUB_OUTPUT"

    - name: Create comment
      uses: marocchino/sticky-pull-request-comment@v2
      with:
        header: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || 'apply' }}
        path: ${{ steps.calculate.outputs.tmpfile }}
        # Action will only use this PR number if it is unable to find the PR number in the PR GitHub event i.e when the PR is merged
        number: ${{ inputs.pull_request_number }}

    - name: Upload data as artifact
      uses: actions/upload-artifact@v4
      continue-on-error: true
      with:
        name: state
        path: state.json
        overwrite: true

    - name: Release the lock
      if: always()
      uses: gruntwork-io/gh-action-mutex@main
      with:
        action: unlock
        ticket_id: ${{ steps.mutex.outputs.ticket_id }}
